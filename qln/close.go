package qln

import (
	"bytes"
	"fmt"

	"github.com/btcsuite/btcd/chaincfg/chainhash"
	"github.com/btcsuite/btcd/wire"
	"github.com/btcsuite/btcutil"
	"github.com/btcsuite/fastsha256"
	"github.com/mit-dci/lit/lnutil"
	"github.com/mit-dci/lit/portxo"
	"github.com/mit-dci/lit/uspv"
)

/* CloseChannel --- cooperative close
This is the simplified close which sends to the same outputs as a break tx,
just with no timeouts.

Users might want a more advanced close function which allows multiple outputs.
They can exchange txouts and sigs.  That could be "fancyClose", but this is
just close, so only a signature is sent by the initiator, and the receiver
doesn't reply, as the channel is closed.

*/

// CloseReqHandler takes in a close request from a remote host, signs and
// responds with a close response.  Obviously later there will be some judgment
// over what to do, but for now it just signs whatever it's requested to.
func (nd *LnNode) CloseReqHandler(from [16]byte, reqbytes []byte) {
	if len(reqbytes) < 100 {
		fmt.Printf("got %d byte closereq, expect 100ish\n", len(reqbytes))
		return
	}

	// figure out who we're talking to
	var peerArr [33]byte
	copy(peerArr[:], nd.RemoteCon.RemotePub.SerializeCompressed())

	// deserialize outpoint
	var opArr [36]byte
	copy(opArr[:], reqbytes[:36])

	// find their sig
	theirSig := reqbytes[36:]

	// get channel
	qc, err := nd.GetQchan(peerArr, opArr)
	if err != nil {
		fmt.Printf("CloseReqHandler GetQchan err %s", err.Error())
		return
	}
	// verify their sig?  should do that before signing our side just to be safe

	// build close tx
	tx, err := qc.SimpleCloseTx()
	if err != nil {
		fmt.Printf("CloseReqHandler SimpleCloseTx err %s", err.Error())
		return
	}

	// sign close
	mySig, err := nd.SignSimpleClose(qc, tx)
	if err != nil {
		fmt.Printf("CloseReqHandler SignSimpleClose err %s", err.Error())
		return
	}
	pre, swap, err := lnutil.FundTxScript(qc.MyPub, qc.TheirPub)
	if err != nil {
		fmt.Printf("CloseReqHandler FundTxScript err %s", err.Error())
		return
	}

	// swap if needed
	if swap {
		tx.TxIn[0].Witness = SpendMultiSigWitStack(pre, theirSig, mySig)
	} else {
		tx.TxIn[0].Witness = SpendMultiSigWitStack(pre, mySig, theirSig)
	}
	fmt.Printf(uspv.TxToString(tx))
	// broadcast
	err = nd.BaseWallet.PushTx(tx)
	if err != nil {
		fmt.Printf("CloseReqHandler NewOutgoingTx err %s", err.Error())
		return
	}

	return
}

// GetCloseTxos takes in a tx and sets the QcloseTXO feilds based on the tx.
// It also returns the spendable (u)txos generated by the close.
// TODO way too long.  Need to split up.
func (q *Qchan) GetCloseTxos(tx *wire.MsgTx) ([]portxo.PorTxo, error) {
	if tx == nil {
		return nil, fmt.Errorf("IngesGetCloseTxostCloseTx: nil tx")
	}
	txid := tx.TxHash()
	// double check -- does this tx actually close the channel?
	if !(len(tx.TxIn) == 1 && lnutil.OutPointsEqual(tx.TxIn[0].PreviousOutPoint, q.Op)) {
		return nil, fmt.Errorf("tx %s doesn't spend channel outpoint %s",
			txid.String(), q.Op.String())
	}
	// hardcode here now... need to save to qchan struct I guess
	q.TimeOut = 5

	// get state index; assume incoming tx uses my hint (broacast by them)
	txIdx := GetStateIdxFromTx(tx, q.GetChanHint(false))
	if txIdx > q.State.StateIdx { // future state, uhoh.  Crash for now.
		return nil, fmt.Errorf("indicated state %d but we know up to %d",
			txIdx, q.State.StateIdx)
	}

	if txIdx == 0 || len(tx.TxOut) != 2 {
		// must have been cooperative, or something else we don't recognize
		// if simple close, still have a PKH output, find it.
		// so far, assume 1 txo

		// no txindx hint, so it's probably cooperative, so most recent
		elk, err := q.ElkSnd.AtIndex(q.State.StateIdx)
		if err != nil {
			return nil, err
		}
		// hash elkrem into elkrem scalar
		elkScalar := chainhash.DoubleHashH(append(elk[:], []byte("POINT")...))

		myPKH := btcutil.Hash160(q.MyRefundPub[:])

		for i, out := range tx.TxOut {
			if len(out.PkScript) < 22 {
				continue // skip to prevent crash
			}
			if bytes.Equal(out.PkScript[2:22], myPKH) { // detected my refund
				var pkhTxo portxo.PorTxo

				pkhTxo.Op.Hash = txid
				pkhTxo.Op.Index = uint32(i)
				pkhTxo.Height = q.CloseData.CloseHeight

				pkhTxo.KeyGen = q.KeyGen

				pkhTxo.PrivKey = elkScalar

				// keypath is the same other than use
				pkhTxo.KeyGen.Step[2] = UseChannelRefund

				pkhTxo.Value = tx.TxOut[i].Value
				pkhTxo.Mode = portxo.TxoP2WPKHComp // witness, normal PKH
				pkhTxo.PkScript = tx.TxOut[i].PkScript

				return []portxo.PorTxo{pkhTxo}, nil
			}
		}
		// couldn't find anything... shouldn't happen
		return nil, fmt.Errorf("channel closed but we got nothing!")
	}

	// non-cooperative / break.

	var shIdx, pkhIdx uint32
	cTxos := make([]portxo.PorTxo, 1)
	// sort outputs into PKH and SH
	if len(tx.TxOut[0].PkScript) == 34 {
		shIdx = 0
		pkhIdx = 1
	} else {
		pkhIdx = 0
		shIdx = 1
	}
	// make sure SH output is actually SH
	if len(tx.TxOut[shIdx].PkScript) != 34 {
		return nil, fmt.Errorf("non-p2sh output is length %d, expect 34",
			len(tx.TxOut[shIdx].PkScript))
	}
	// make sure PKH output is actually PKH
	if len(tx.TxOut[pkhIdx].PkScript) != 22 {
		return nil, fmt.Errorf("non-p2wsh output is length %d, expect 22",
			len(tx.TxOut[pkhIdx].PkScript))
	}

	// use the indicated state to generate refund pkh (it may be old)

	// refund PKHs come from the refund base plus their elkrem point.
	theirElkPoint, err := q.ElkPoint(false, txIdx)
	if err != nil {
		return nil, err
	}

	myPKH := btcutil.Hash160(q.MyRefundPub[:])

	// indirectly check if SH is mine
	if !bytes.Equal(tx.TxOut[pkhIdx].PkScript[2:22], myPKH) {
		// ------------pkh not mine; assume SH is mine
		// build script to store in porTxo
		timeoutPub := lnutil.CombinePubs(q.MyHAKDBase, theirElkPoint)
		revokePub := lnutil.CombinePubs(q.TheirHAKDBase, theirElkPoint)

		script := lnutil.CommitScript(revokePub, timeoutPub, q.TimeOut)

		// create the ScriptHash, timeout portxo.
		var shTxo portxo.PorTxo // create new utxo and copy into it
		// use txidx's elkrem as it may not be most recent
		elk, err := q.ElkSnd.AtIndex(txIdx)
		if err != nil {
			return nil, err
		}
		// keypath is the same, except for use
		shTxo.KeyGen = q.KeyGen

		shTxo.Op.Hash = txid
		shTxo.Op.Index = shIdx
		shTxo.Height = q.CloseData.CloseHeight
		shTxo.KeyGen.Step[2] = UseChannelHAKDBase
		// hash elkrem into elkrem T scalar (0x74 == 't')
		shTxo.PrivKey = chainhash.DoubleHashH(append(elk.CloneBytes(), 0x74))

		shTxo.Mode = portxo.TxoP2WSHComp

		shTxo.Value = tx.TxOut[shIdx].Value
		shTxo.Seq = uint32(q.TimeOut)
		shTxo.PreSigStack = make([][]byte, 1) // revoke SH has one presig item
		shTxo.PreSigStack[0] = nil            // and that item is a nil (timeout)

		// script check
		genSH := fastsha256.Sum256(script)
		if !bytes.Equal(genSH[:], tx.TxOut[shIdx].PkScript[2:34]) {
			fmt.Printf("got different observed and generated SH scripts.\n")
			fmt.Printf("in %s:%d, see %x\n", txid, shIdx, tx.TxOut[shIdx].PkScript)
			fmt.Printf("generated %x \n", genSH)
			fmt.Printf("revokable pub %x\ntimeout pub %x\n", revokePub, timeoutPub)
		}
		shTxo.PkScript = script

		cTxos[0] = shTxo
		// if SH is mine we're done
		return cTxos, nil
	}

	// ---------- pkh is mine
	var pkhTxo portxo.PorTxo // create new utxo and copy into it

	// use txidx's elkrem as it may not be most recent
	elk, err := q.ElkSnd.AtIndex(txIdx)
	if err != nil {
		return nil, err
	}
	elkScalar := chainhash.DoubleHashH(append(elk[:], []byte("POINT")...))

	pkhScript := lnutil.DirectWPKHScript(q.MyRefundPub)

	// check if re-created script matches observed script (hash)
	if !bytes.Equal(tx.TxOut[pkhIdx].PkScript, pkhScript) {
		// probably should error out here
		fmt.Printf("got different observed and generated pkh scripts.\n")
		fmt.Printf("in %s : %d see %x\n", txid, pkhIdx, tx.TxOut[pkhIdx].PkScript)
		fmt.Printf("generated %x from sender (/ their) elkR %d\n", pkhScript, txIdx)
		fmt.Printf("base refund pub %x\n", q.MyRefundPub)
	}

	pkhTxo.Op.Hash = txid
	pkhTxo.Op.Index = pkhIdx
	pkhTxo.Height = q.CloseData.CloseHeight
	// keypath same, use different
	pkhTxo.KeyGen = q.KeyGen
	// same keygen as underlying channel, but use is refund
	pkhTxo.KeyGen.Step[2] = UseChannelRefund
	// hash elkrem into elkrem R scalar (0x72 == 'r')
	pkhTxo.PrivKey = elkScalar
	pkhTxo.Mode = portxo.TxoP2WPKHComp
	pkhTxo.Value = tx.TxOut[pkhIdx].Value
	// PKH, so script is easy
	pkhTxo.PkScript = tx.TxOut[pkhIdx].PkScript
	cTxos[0] = pkhTxo

	// OK, it's my PKH, but can I ALSO grab the SH??? (revoked)
	if txIdx < q.State.StateIdx {
		// ---------- revoked SH is mine
		// invalid previous state, can be grabbed!
		// make MY elk points
		myElkPoint, err := q.ElkPoint(true, txIdx)
		if err != nil {
			return nil, err
		}

		timeoutPub := lnutil.CombinePubs(q.TheirHAKDBase, myElkPoint)
		revokePub := lnutil.CombinePubs(q.MyHAKDBase, myElkPoint)
		script := lnutil.CommitScript(revokePub, timeoutPub, q.TimeOut)

		// script check
		wshScript := lnutil.P2WSHify(script)
		if !bytes.Equal(wshScript[:], tx.TxOut[shIdx].PkScript) {
			fmt.Printf("got different observed and generated SH scripts.\n")
			fmt.Printf("in %s:%d, see %x\n", txid, shIdx, tx.TxOut[shIdx].PkScript)
			fmt.Printf("generated %x \n", wshScript)
			fmt.Printf("revokable pub %x\ntimeout pub %x\n", revokePub, timeoutPub)
		}

		// myElkHashR added to HAKD private key
		elk, err := q.ElkRcv.AtIndex(txIdx)
		if err != nil {
			return nil, err
		}

		var shTxo portxo.PorTxo // create new utxo and copy into it
		shTxo.KeyGen = q.KeyGen
		shTxo.Op.Hash = txid
		shTxo.Op.Index = shIdx
		shTxo.Height = q.CloseData.CloseHeight

		shTxo.KeyGen.Step[2] = UseChannelHAKDBase

		shTxo.PrivKey = chainhash.DoubleHashH(append(elk.CloneBytes(), 0x72)) // 'r'

		shTxo.PkScript = script

		shTxo.Value = tx.TxOut[shIdx].Value
		shTxo.Mode = portxo.TxoP2WSHComp
		shTxo.Seq = 1                         // 1 means grab immediately
		shTxo.PreSigStack = make([][]byte, 1) // timeout SH has one presig item
		shTxo.PreSigStack[0] = []byte{0x01}   // and that item is a 1 (justice)
		cTxos = append(cTxos, shTxo)
	}

	return cTxos, nil
}
